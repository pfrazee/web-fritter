(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('events'), require('buffer')) :
	typeof define === 'function' && define.amd ? define(['events', 'buffer'], factory) :
	(global['random-access-idb-mutable-file'] = factory(global.events,global.buffer));
}(this, (function (events,buffer) { 'use strict';

	events = events && events.hasOwnProperty('default') ? events['default'] : events;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var inherits_browser = createCommonjsModule(function (module) {
	if (typeof Object.create === 'function') {
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	});

	var NOT_READABLE = defaultImpl(new Error('Not readable'));
	var NOT_WRITABLE = defaultImpl(new Error('Not writable'));
	var NOT_DELETABLE = defaultImpl(new Error('Not deletable'));
	var NOT_STATABLE = defaultImpl(new Error('Not statable'));
	var NO_OPEN_READABLE = defaultImpl(new Error('No readonly open'));

	var randomAccessStorage = RandomAccess;

	function RandomAccess(opts) {
	  if (!(this instanceof RandomAccess)) return new RandomAccess(opts);
	  events.EventEmitter.call(this);

	  this._queued = [];
	  this._pending = 0;
	  this._needsOpen = true;

	  this.opened = false;
	  this.closed = false;
	  this.destroyed = false;

	  if (opts) {
	    if (opts.openReadonly) this._openReadonly = opts.openReadonly;
	    if (opts.open) this._open = opts.open;
	    if (opts.read) this._read = opts.read;
	    if (opts.write) this._write = opts.write;
	    if (opts.del) this._del = opts.del;
	    if (opts.stat) this._stat = opts.stat;
	    if (opts.close) this._close = opts.close;
	    if (opts.destroy) this._destroy = opts.destroy;
	  }

	  this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE;
	  this.readable = this._read !== NOT_READABLE;
	  this.writable = this._write !== NOT_WRITABLE;
	  this.deletable = this._del !== NOT_DELETABLE;
	  this.statable = this._stat !== NOT_STATABLE;
	}

	inherits_browser(RandomAccess, events.EventEmitter);

	RandomAccess.prototype.open = function (cb) {
	  if (!cb) cb = noop;
	  if (this.opened && !this._needsOpen) return process.nextTick(cb, null);
	  queueAndRun(this, new Request(this, 0, 0, 0, null, cb));
	};

	RandomAccess.prototype._open = defaultImpl(null);
	RandomAccess.prototype._openReadonly = NO_OPEN_READABLE;

	RandomAccess.prototype.read = function (offset, size, cb) {
	  this.run(new Request(this, 1, offset, size, null, cb));
	};

	RandomAccess.prototype._read = NOT_READABLE;

	RandomAccess.prototype.write = function (offset, data, cb) {
	  if (!cb) cb = noop;
	  openWritable(this);
	  this.run(new Request(this, 2, offset, data.length, data, cb));
	};

	RandomAccess.prototype._write = NOT_WRITABLE;

	RandomAccess.prototype.del = function (offset, size, cb) {
	  if (!cb) cb = noop;
	  openWritable(this);
	  this.run(new Request(this, 3, offset, size, null, cb));
	};

	RandomAccess.prototype._del = NOT_DELETABLE;

	RandomAccess.prototype.stat = function (cb) {
	  this.run(new Request(this, 4, 0, 0, null, cb));
	};

	RandomAccess.prototype._stat = NOT_STATABLE;

	RandomAccess.prototype.close = function (cb) {
	  if (!cb) cb = noop;
	  if (this.closed) return process.nextTick(cb, null);
	  queueAndRun(this, new Request(this, 5, 0, 0, null, cb));
	};

	RandomAccess.prototype._close = defaultImpl(null);

	RandomAccess.prototype.destroy = function (cb) {
	  if (!cb) cb = noop;
	  if (!this.closed) this.close(noop);
	  queueAndRun(this, new Request(this, 6, 0, 0, null, cb));
	};

	RandomAccess.prototype._destroy = defaultImpl(null);

	RandomAccess.prototype.run = function (req) {
	  if (this._needsOpen) this.open(noop);
	  if (this._queued.length) this._queued.push(req);else req._run();
	};

	function noop() {}

	function Request(self, type, offset, size, data, cb) {
	  this.type = type;
	  this.offset = offset;
	  this.data = data;
	  this.size = size;
	  this.storage = self;

	  this._sync = false;
	  this._callback = cb;
	  this._openError = null;
	}

	Request.prototype._maybeOpenError = function (err) {
	  if (this.type !== 0) return;
	  var queued = this.storage._queued;
	  for (var i = 0; i < queued.length; i++) {
	    queued[i]._openError = err;
	  }
	};

	Request.prototype._unqueue = function (err) {
	  var ra = this.storage;
	  var queued = ra._queued;

	  if (!err) {
	    switch (this.type) {
	      case 0:
	        if (!ra.opened) {
	          ra.opened = true;
	          ra.emit('open');
	        }
	        break;

	      case 5:
	        if (!ra.closed) {
	          ra.closed = true;
	          ra.emit('close');
	        }
	        break;

	      case 6:
	        if (!ra.destroyed) {
	          ra.destroyed = true;
	          ra.emit('destroy');
	        }
	        break;
	    }
	  } else {
	    this._maybeOpenError(err);
	  }

	  if (queued.length && queued[0] === this) queued.shift();
	  if (! --ra._pending && queued.length) queued[0]._run();
	};

	Request.prototype.callback = function (err, val) {
	  if (this._sync) return nextTick(this, err, val);
	  this._unqueue(err);
	  this._callback(err, val);
	};

	Request.prototype._openAndNotClosed = function () {
	  var ra = this.storage;
	  if (ra.opened && !ra.closed) return true;
	  if (!ra.opened) nextTick(this, this._openError || new Error('Not opened'));else if (ra.closed) nextTick(this, new Error('Closed'));
	  return false;
	};

	Request.prototype._open = function () {
	  var ra = this.storage;

	  if (ra.opened && !ra._needsOpen) return nextTick(this, null);
	  if (ra.closed) return nextTick(this, new Error('Closed'));

	  ra._needsOpen = false;
	  if (ra.preferReadonly) ra._openReadonly(this);else ra._open(this);
	};

	Request.prototype._run = function () {
	  var ra = this.storage;
	  ra._pending++;

	  this._sync = true;

	  switch (this.type) {
	    case 0:
	      this._open();
	      break;

	    case 1:
	      if (this._openAndNotClosed()) ra._read(this);
	      break;

	    case 2:
	      if (this._openAndNotClosed()) ra._write(this);
	      break;

	    case 3:
	      if (this._openAndNotClosed()) ra._del(this);
	      break;

	    case 4:
	      if (this._openAndNotClosed()) ra._stat(this);
	      break;

	    case 5:
	      if (ra.closed || !ra.opened) nextTick(this, null);else ra._close(this);
	      break;

	    case 6:
	      if (ra.destroyed) nextTick(this, null);else ra._destroy(this);
	      break;
	  }

	  this._sync = false;
	};

	function queueAndRun(self, req) {
	  self._queued.push(req);
	  if (!self._pending) req._run();
	}

	function openWritable(self) {
	  if (self.preferReadonly) {
	    self._needsOpen = true;
	    self.preferReadonly = false;
	  }
	}

	function defaultImpl(err) {
	  return overridable;

	  function overridable(req) {
	    nextTick(req, err);
	  }
	}

	function nextTick(req, err, val) {
	  process.nextTick(nextTickCallback, req, err, val);
	}

	function nextTickCallback(req, err, val) {
	  req.callback(err, val);
	}

	var indexedDB = window.indexedDB;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var promise = function promise(request) {
	  return new Promise(function (resolve, reject) {
	    request.onsuccess = function () {
	      return resolve(request.result);
	    };
	    request.onerror = function () {
	      return reject(request.error);
	    };
	  });
	};

	var RandomAccessIDBFileVolume = function () {
	  function RandomAccessIDBFileVolume(db, name, version, storeName, options) {
	    _classCallCheck(this, RandomAccessIDBFileVolume);

	    this.db = db;
	    this.name = name;
	    this.version = version;
	    this.storeName = storeName;
	    this.options = options;
	  }

	  _createClass(RandomAccessIDBFileVolume, [{
	    key: "store",
	    value: function store() {
	      var db = this.db,
	          storeName = this.storeName;

	      var transaction = db.transaction([storeName], "readwrite");
	      return transaction.objectStore(storeName);
	    }
	  }, {
	    key: "delete",
	    value: function () {
	      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(url) {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return promise(this.store().delete(url));

	              case 2:
	                return _context.abrupt("return", _context.sent);

	              case 3:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function _delete(_x) {
	        return _ref.apply(this, arguments);
	      }

	      return _delete;
	    }()
	  }, {
	    key: "save",
	    value: function () {
	      var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(url, file) {
	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return promise(this.store().put(file, url));

	              case 2:
	                return _context2.abrupt("return", _context2.sent);

	              case 3:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function save(_x2, _x3) {
	        return _ref2.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: "open",
	    value: function () {
	      var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(url, mode) {
	        var file, _file;

	        return regeneratorRuntime.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                _context3.next = 2;
	                return promise(this.store().get(url));

	              case 2:
	                file = _context3.sent;

	                if (!file) {
	                  _context3.next = 7;
	                  break;
	                }

	                return _context3.abrupt("return", file);

	              case 7:
	                if (!(mode === "readwrite")) {
	                  _context3.next = 16;
	                  break;
	                }

	                _context3.next = 10;
	                return promise(this.db.createMutableFile(url, "binary/random"));

	              case 10:
	                _file = _context3.sent;
	                _context3.next = 13;
	                return this.save(url, _file);

	              case 13:
	                return _context3.abrupt("return", _file);

	              case 16:
	                throw new RangeError("File " + url + " does not exist");

	              case 17:
	              case "end":
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function open(_x4, _x5) {
	        return _ref3.apply(this, arguments);
	      }

	      return open;
	    }()
	  }, {
	    key: "mount",
	    value: function mount(file, options) {
	      return new RandomAccessProvider(this, "/" + file, options);
	    }
	  }]);

	  return RandomAccessIDBFileVolume;
	}();

	var RandomAccessProvider = function (_RandomAccess) {
	  _inherits(RandomAccessProvider, _RandomAccess);

	  _createClass(RandomAccessProvider, [{
	    key: "_open",
	    value: function _open(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_openReadonly",
	    value: function _openReadonly(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_write",
	    value: function _write(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_read",
	    value: function _read(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_del",
	    value: function _del(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_stat",
	    value: function _stat(request) {
	      RandomAccessProvider.perform(this, request);
	    }
	  }, {
	    key: "_close",
	    value: function _close(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }, {
	    key: "_destroy",
	    value: function _destroy(request) {
	      RandomAccessProvider.schedule(this, request);
	    }
	  }], [{
	    key: "mount",
	    value: function () {
	      var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	        var _name, _version, _storeName, request, db, volume;

	        return regeneratorRuntime.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                if (self.IDBMutableFile) {
	                  _context4.next = 4;
	                  break;
	                }

	                throw Error("Runtime does not supports IDBMutableFile https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile");

	              case 4:
	                _name = options.name || "RandomAccess";
	                _version = options.version || 1.0;
	                _storeName = options.storeName || "IDBMutableFile";
	                request = indexedDB.open(_name, _version);

	                request.onupgradeneeded = function () {
	                  var db = request.result;
	                  if (!db.objectStoreNames.contains(_storeName)) {
	                    db.createObjectStore(_storeName);
	                  }
	                };
	                _context4.next = 11;
	                return promise(request);

	              case 11:
	                db = _context4.sent;
	                volume = new RandomAccessIDBFileVolume(db, _name, _version, _storeName, options);
	                return _context4.abrupt("return", function (path, options) {
	                  return volume.mount(path, options);
	                });

	              case 14:
	              case "end":
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function mount() {
	        return _ref4.apply(this, arguments);
	      }

	      return mount;
	    }()
	  }, {
	    key: "open",
	    value: function () {
	      var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(self, request) {
	        var options, mode, file;
	        return regeneratorRuntime.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                options = self.options;
	                mode = request.preferReadonly ? "readonly" : "readwrite";

	                self.debug && console.log(">> open " + self.url + " " + mode);

	                if (!(!self.file || self.mode !== mode && mode === "readwrite")) {
	                  _context5.next = 8;
	                  break;
	                }

	                self.mode = mode;
	                _context5.next = 7;
	                return self.volume.open(self.url, mode);

	              case 7:
	                self.file = _context5.sent;

	              case 8:
	                if (mode === "readonly" || !options.truncate) {
	                  _context5.next = 12;
	                  break;
	                }

	                file = self.activate();
	                _context5.next = 12;
	                return promise(file.truncate(options.size || 0));

	              case 12:

	                self.debug && console.log("<< open " + self.url + " " + mode);

	              case 13:
	              case "end":
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function open(_x7, _x8) {
	        return _ref5.apply(this, arguments);
	      }

	      return open;
	    }()
	  }, {
	    key: "read",
	    value: function () {
	      var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(self, _ref6) {
	        var data = _ref6.data,
	            offset = _ref6.offset,
	            size = _ref6.size;
	        var buffer$$1, file, chunk;
	        return regeneratorRuntime.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                self.debug && console.log(">> read " + self.url + " <" + offset + ", " + size + ">");
	                buffer$$1 = data || buffer.Buffer.allocUnsafe(size);

	                if (!(size === 0)) {
	                  _context6.next = 4;
	                  break;
	                }

	                return _context6.abrupt("return", buffer$$1);

	              case 4:
	                file = self.activate();

	                file.location = offset;
	                _context6.next = 8;
	                return promise(file.readAsArrayBuffer(size));

	              case 8:
	                chunk = _context6.sent;

	                if (!(chunk.byteLength !== size)) {
	                  _context6.next = 11;
	                  break;
	                }

	                throw new Error("Could not satisfy length");

	              case 11:

	                buffer.Buffer.from(chunk).copy(buffer$$1);
	                self.debug && console.log("<< read " + self.url + " <" + offset + ", " + size + ">", buffer$$1);
	                return _context6.abrupt("return", buffer$$1);

	              case 14:
	              case "end":
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this);
	      }));

	      function read(_x9, _x10) {
	        return _ref7.apply(this, arguments);
	      }

	      return read;
	    }()
	  }, {
	    key: "write",
	    value: function () {
	      var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(self, _ref8) {
	        var data = _ref8.data,
	            offset = _ref8.offset,
	            size = _ref8.size;
	        var byteLength, byteOffset, chunk, file, wrote;
	        return regeneratorRuntime.wrap(function _callee7$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                self.debug && console.log(">> write " + self.url + " <" + offset + ", " + size + ">", data);
	                byteLength = data.byteLength, byteOffset = data.byteOffset;
	                chunk = byteLength === size ? data : data.slice(0, size);
	                file = self.activate();

	                file.location = offset;
	                _context7.next = 7;
	                return promise(file.write(chunk));

	              case 7:
	                wrote = _context7.sent;


	                self.debug && console.log("<< write " + self.url + " <" + offset + ", " + size + ">");

	                return _context7.abrupt("return", wrote);

	              case 10:
	              case "end":
	                return _context7.stop();
	            }
	          }
	        }, _callee7, this);
	      }));

	      function write(_x11, _x12) {
	        return _ref9.apply(this, arguments);
	      }

	      return write;
	    }()
	  }, {
	    key: "delete",
	    value: function () {
	      var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8(self, _ref10) {
	        var offset = _ref10.offset,
	            size = _ref10.size;
	        var stat, file;
	        return regeneratorRuntime.wrap(function _callee8$(_context8) {
	          while (1) {
	            switch (_context8.prev = _context8.next) {
	              case 0:
	                self.debug && console.log(">> delete " + self.url + " <" + offset + ", " + size + ">");
	                _context8.next = 3;
	                return this.stat(self);

	              case 3:
	                stat = _context8.sent;

	                if (!(offset + size >= stat.size)) {
	                  _context8.next = 8;
	                  break;
	                }

	                file = self.activate();
	                _context8.next = 8;
	                return promise(file.truncate(offset));

	              case 8:

	                self.debug && console.log("<< delete " + self.url + " <" + offset + ", " + size + ">");

	              case 9:
	              case "end":
	                return _context8.stop();
	            }
	          }
	        }, _callee8, this);
	      }));

	      function _delete(_x13, _x14) {
	        return _ref11.apply(this, arguments);
	      }

	      return _delete;
	    }()
	  }, {
	    key: "stat",
	    value: function () {
	      var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9(self) {
	        var file, stat;
	        return regeneratorRuntime.wrap(function _callee9$(_context9) {
	          while (1) {
	            switch (_context9.prev = _context9.next) {
	              case 0:
	                self.debug && console.log(">> stat " + self.url);
	                file = self.activate();
	                _context9.next = 4;
	                return promise(file.getMetadata());

	              case 4:
	                stat = _context9.sent;

	                self.debug && console.log("<< stat {size:" + stat.size + "} " + self.url + " ");

	                return _context9.abrupt("return", stat);

	              case 7:
	              case "end":
	                return _context9.stop();
	            }
	          }
	        }, _callee9, this);
	      }));

	      function stat(_x15) {
	        return _ref12.apply(this, arguments);
	      }

	      return stat;
	    }()
	  }, {
	    key: "close",
	    value: function () {
	      var _ref13 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(self) {
	        var lockedFile;
	        return regeneratorRuntime.wrap(function _callee10$(_context10) {
	          while (1) {
	            switch (_context10.prev = _context10.next) {
	              case 0:
	                self.debug && console.log(">> close " + self.url);
	                lockedFile = self.lockedFile;

	                if (!(lockedFile && lockedFile.active)) {
	                  _context10.next = 5;
	                  break;
	                }

	                _context10.next = 5;
	                return promise(lockedFile.flush());

	              case 5:
	                self.lockedFile = null;
	                self.file = null;
	                self.debug && console.log("<< close " + self.url);

	              case 8:
	              case "end":
	                return _context10.stop();
	            }
	          }
	        }, _callee10, this);
	      }));

	      function close(_x16) {
	        return _ref13.apply(this, arguments);
	      }

	      return close;
	    }()
	  }, {
	    key: "destroy",
	    value: function () {
	      var _ref14 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(self) {
	        return regeneratorRuntime.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                self.debug && console.log(">> destroy " + self.url);
	                _context11.next = 3;
	                return self.volume.delete(self.url);

	              case 3:
	                self.debug && console.log("<< destroy " + self.url);

	              case 4:
	              case "end":
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this);
	      }));

	      function destroy(_x17) {
	        return _ref14.apply(this, arguments);
	      }

	      return destroy;
	    }()
	  }, {
	    key: "awake",
	    value: function () {
	      var _ref15 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(self) {
	        var workQueue, index, request;
	        return regeneratorRuntime.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                workQueue = self.workQueue;

	                self.isIdle = false;
	                index = 0;

	              case 3:
	                if (!(index < workQueue.length)) {
	                  _context12.next = 9;
	                  break;
	                }

	                request = workQueue[index++];
	                _context12.next = 7;
	                return this.perform(self, request);

	              case 7:
	                _context12.next = 3;
	                break;

	              case 9:
	                workQueue.length = 0;
	                self.isIdle = true;

	              case 11:
	              case "end":
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this);
	      }));

	      function awake(_x18) {
	        return _ref15.apply(this, arguments);
	      }

	      return awake;
	    }()
	  }, {
	    key: "schedule",
	    value: function schedule(self, request) {
	      self.workQueue.push(request);
	      if (self.isIdle) {
	        this.awake(self);
	      }
	    }
	  }, {
	    key: "perform",
	    value: function () {
	      var _ref16 = _asyncToGenerator(regeneratorRuntime.mark(function _callee13(self, request) {
	        return regeneratorRuntime.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                _context13.prev = 0;
	                _context13.t0 = request.type;
	                _context13.next = _context13.t0 === RequestType.open ? 4 : _context13.t0 === RequestType.read ? 9 : _context13.t0 === RequestType.write ? 14 : _context13.t0 === RequestType.delete ? 19 : _context13.t0 === RequestType.stat ? 24 : _context13.t0 === RequestType.close ? 29 : _context13.t0 === RequestType.destroy ? 34 : 39;
	                break;

	              case 4:
	                _context13.t1 = request;
	                _context13.next = 7;
	                return this.open(self, request);

	              case 7:
	                _context13.t2 = _context13.sent;
	                return _context13.abrupt("return", _context13.t1.callback.call(_context13.t1, null, _context13.t2));

	              case 9:
	                _context13.t3 = request;
	                _context13.next = 12;
	                return this.read(self, request);

	              case 12:
	                _context13.t4 = _context13.sent;
	                return _context13.abrupt("return", _context13.t3.callback.call(_context13.t3, null, _context13.t4));

	              case 14:
	                _context13.t5 = request;
	                _context13.next = 17;
	                return this.write(self, request);

	              case 17:
	                _context13.t6 = _context13.sent;
	                return _context13.abrupt("return", _context13.t5.callback.call(_context13.t5, null, _context13.t6));

	              case 19:
	                _context13.t7 = request;
	                _context13.next = 22;
	                return this.delete(self, request);

	              case 22:
	                _context13.t8 = _context13.sent;
	                return _context13.abrupt("return", _context13.t7.callback.call(_context13.t7, null, _context13.t8));

	              case 24:
	                _context13.t9 = request;
	                _context13.next = 27;
	                return this.stat(self);

	              case 27:
	                _context13.t10 = _context13.sent;
	                return _context13.abrupt("return", _context13.t9.callback.call(_context13.t9, null, _context13.t10));

	              case 29:
	                _context13.t11 = request;
	                _context13.next = 32;
	                return this.close(self);

	              case 32:
	                _context13.t12 = _context13.sent;
	                return _context13.abrupt("return", _context13.t11.callback.call(_context13.t11, null, _context13.t12));

	              case 34:
	                _context13.t13 = request;
	                _context13.next = 37;
	                return this.destroy(self);

	              case 37:
	                _context13.t14 = _context13.sent;
	                return _context13.abrupt("return", _context13.t13.callback.call(_context13.t13, null, _context13.t14));

	              case 39:
	                _context13.next = 44;
	                break;

	              case 41:
	                _context13.prev = 41;
	                _context13.t15 = _context13["catch"](0);

	                request.callback(_context13.t15);

	              case 44:
	              case "end":
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this, [[0, 41]]);
	      }));

	      function perform(_x19, _x20) {
	        return _ref16.apply(this, arguments);
	      }

	      return perform;
	    }()
	  }]);

	  function RandomAccessProvider(volume, url) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	    _classCallCheck(this, RandomAccessProvider);

	    var _this = _possibleConstructorReturn(this, (RandomAccessProvider.__proto__ || Object.getPrototypeOf(RandomAccessProvider)).call(this));

	    _this.volume = volume;
	    _this.url = url;
	    _this.options = options;
	    _this.mode = "readonly";
	    _this.file = null;
	    _this.lockedFile = null;

	    _this.workQueue = [];
	    _this.isIdle = true;
	    _this.debug = !!volume.options.debug;
	    return _this;
	  }

	  _createClass(RandomAccessProvider, [{
	    key: "activate",
	    value: function activate() {
	      var lockedFile = this.lockedFile,
	          file = this.file,
	          mode = this.mode;

	      if (lockedFile && lockedFile.active) {
	        return lockedFile;
	      } else if (file) {
	        var _lockedFile = file.open(mode);
	        this.lockedFile = _lockedFile;
	        return _lockedFile;
	      } else {
	        throw new RangeError("Unable to activate file, likely provider was destroyed");
	      }
	    }
	  }]);

	  return RandomAccessProvider;
	}(randomAccessStorage);

	var RequestType = {
	  open: 0,
	  read: 1,
	  write: 2,
	  delete: 3,
	  stat: 4,
	  close: 5,
	  destroy: 6
	};
	module.exports = exports["default"];

	return RandomAccessProvider;

})));
//# sourceMappingURL=random-access-idb-mutable-file.js.map
